---
phase: 02-owner-property-data
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/lib/validators/nie-nif.ts
  - src/lib/validators/iban.ts
  - src/lib/validators/cadastral.ts
  - src/lib/validators/ownership.ts
  - src/lib/validators/index.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "NIE/NIF validation uses checksum algorithm (not just regex)"
    - "IBAN validation handles spaces and returns error codes"
    - "Cadastral reference validation uses 20-character checksum"
    - "Ownership percentage validation uses basis points to avoid floating point issues"
  artifacts:
    - path: "src/lib/validators/nie-nif.ts"
      provides: "NIE/NIF validation using better-dni library"
      exports: ["validateNieNif", "getNieNifType", "normalizeNieNif"]
    - path: "src/lib/validators/iban.ts"
      provides: "IBAN validation using ibantools library"
      exports: ["validateIban", "formatIbanForStorage"]
    - path: "src/lib/validators/cadastral.ts"
      provides: "Cadastral reference validation (custom implementation)"
      exports: ["validateCadastralReference"]
    - path: "src/lib/validators/ownership.ts"
      provides: "Ownership percentage validation"
      exports: ["validateOwnershipPercentages"]
    - path: "package.json"
      provides: "Validation libraries"
      contains: "better-dni, ibantools"
  key_links:
    - from: "src/lib/validators/nie-nif.ts"
      to: "better-dni"
      via: "import"
      pattern: "import.*from.*better-dni"
    - from: "src/lib/validators/iban.ts"
      to: "ibantools"
      via: "import"
      pattern: "import.*from.*ibantools"
---

<objective>
Create validation utilities for Spanish tax identifiers (NIE/NIF), IBAN bank accounts, cadastral references, and ownership percentages.

Purpose: All forms in Phase 2 require proper validation with checksum verification for data integrity
Output: Reusable validator functions that can be integrated with Zod schemas
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-owner-property-data/02-RESEARCH.md

# Research provides:
# - better-dni library usage for NIE/NIF
# - ibantools library usage for IBAN
# - Custom cadastral validation algorithm
# - Ownership percentage validation with basis points
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install validation libraries</name>
  <files>package.json</files>
  <action>
Install better-dni and ibantools for Spanish ID and bank account validation:

```bash
npm install better-dni ibantools
```

These libraries provide:
- better-dni: NIE/NIF validation with checksum (fastest, TypeScript-native)
- ibantools: IBAN validation with error codes (zero dependencies)
  </action>
  <verify>
Run: `npm ls better-dni ibantools` confirms both packages installed
  </verify>
  <done>better-dni and ibantools appear in package.json dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create validation utility modules</name>
  <files>
    src/lib/validators/nie-nif.ts
    src/lib/validators/iban.ts
    src/lib/validators/cadastral.ts
    src/lib/validators/ownership.ts
    src/lib/validators/index.ts
  </files>
  <action>
Create src/lib/validators/ directory with the following files:

**1. nie-nif.ts** - NIE/NIF validation using better-dni:
```typescript
import { isValid, isNIF, isNIE, normalize } from 'better-dni';

export function validateNieNif(value: string): boolean {
  if (!value) return false;
  const normalized = normalize(value);
  return isValid(normalized);
}

export function getNieNifType(value: string): 'NIF' | 'NIE' | null {
  if (!value) return null;
  const normalized = normalize(value);
  if (isNIF(normalized)) return 'NIF';
  if (isNIE(normalized)) return 'NIE';
  return null;
}

export function normalizeNieNif(value: string): string {
  return normalize(value);
}
```

**2. iban.ts** - IBAN validation using ibantools:
```typescript
import {
  electronicFormatIBAN,
  validateIBAN,
  ValidationErrorsIBAN
} from 'ibantools';

export interface IbanValidationResult {
  valid: boolean;
  errorCode?: string;
  formatted?: string;
}

export function validateIban(iban: string): IbanValidationResult {
  if (!iban) {
    return { valid: false, errorCode: 'ibanRequired' };
  }

  const electronic = electronicFormatIBAN(iban) || '';
  const result = validateIBAN(electronic);

  if (result.valid) {
    return { valid: true, formatted: electronic };
  }

  // Map error codes to translation keys
  const errorMap: Record<number, string> = {
    [ValidationErrorsIBAN.NoIBANProvided]: 'ibanRequired',
    [ValidationErrorsIBAN.NoIBANCountry]: 'ibanCountryInvalid',
    [ValidationErrorsIBAN.WrongBBANLength]: 'ibanLengthInvalid',
    [ValidationErrorsIBAN.WrongIBANChecksum]: 'ibanChecksumInvalid',
  };

  const errorCode = result.errorCodes?.[0];
  return {
    valid: false,
    errorCode: errorMap[errorCode] || 'ibanInvalid',
  };
}

export function formatIbanForStorage(iban: string): string {
  return electronicFormatIBAN(iban) || '';
}
```

**3. cadastral.ts** - Cadastral reference validation (custom, from research):
```typescript
const POSITION_WEIGHTS = [13, 15, 12, 5, 4, 17, 9, 21, 3, 7, 1];
const CONTROL_LETTERS = 'MQWERTYUIOPASDFGHJKLBZX';

function charToValue(char: string): number {
  const code = char.charCodeAt(0);
  if (char >= '0' && char <= '9') {
    return parseInt(char, 10);
  }
  if (char >= 'A' && char <= 'N') {
    return code - 64; // A=1, B=2, ..., N=14
  }
  if (char > 'N') {
    return code - 63; // O=16, P=17, ..., Z=27
  }
  return 0;
}

function calculateControlDigit(sequence: string): string {
  let sum = 0;
  for (let i = 0; i < sequence.length && i < POSITION_WEIGHTS.length; i++) {
    const value = charToValue(sequence[i]);
    sum = (sum + value * POSITION_WEIGHTS[i]) % 23;
  }
  return CONTROL_LETTERS[sum];
}

export function validateCadastralReference(ref: string): boolean {
  if (!ref || ref.length !== 20) {
    return false;
  }

  const normalized = ref.toUpperCase().replace(/\s/g, '');
  if (normalized.length !== 20) {
    return false;
  }

  // Validate alphanumeric only
  if (!/^[A-Z0-9]{20}$/.test(normalized)) {
    return false;
  }

  // First control digit: positions 0-6 + 14-17
  const firstSequence = normalized.substring(0, 7) + normalized.substring(14, 18);
  const expectedFirst = calculateControlDigit(firstSequence);

  // Second control digit: positions 7-13 + 14-17
  const secondSequence = normalized.substring(7, 14) + normalized.substring(14, 18);
  const expectedSecond = calculateControlDigit(secondSequence);

  const actualControls = normalized.substring(18, 20);
  return actualControls === expectedFirst + expectedSecond;
}

export function normalizeCadastralReference(ref: string): string {
  return ref.toUpperCase().replace(/\s/g, '');
}
```

**4. ownership.ts** - Ownership percentage validation:
```typescript
export interface OwnershipEntry {
  ownerId: string;
  percentage: number;
}

export interface OwnershipValidationResult {
  valid: boolean;
  errorCode?: string;
}

export function validateOwnershipPercentages(
  entries: OwnershipEntry[]
): OwnershipValidationResult {
  if (entries.length === 0) {
    return { valid: false, errorCode: 'atLeastOneOwner' };
  }

  // Use basis points (integer) to avoid floating point issues
  // 100% = 10000 basis points
  const totalBasisPoints = entries.reduce((sum, entry) => {
    return sum + Math.round(entry.percentage * 100);
  }, 0);

  if (totalBasisPoints !== 10000) {
    const difference = (10000 - totalBasisPoints) / 100;
    return {
      valid: false,
      errorCode: difference > 0 ? 'percentageUnder100' : 'percentageOver100'
    };
  }

  // Check individual entries
  for (const entry of entries) {
    if (entry.percentage <= 0) {
      return { valid: false, errorCode: 'percentageMustBePositive' };
    }
    if (entry.percentage > 100) {
      return { valid: false, errorCode: 'percentageExceeds100' };
    }
  }

  return { valid: true };
}
```

**5. index.ts** - Barrel export:
```typescript
export { validateNieNif, getNieNifType, normalizeNieNif } from './nie-nif';
export { validateIban, formatIbanForStorage, type IbanValidationResult } from './iban';
export { validateCadastralReference, normalizeCadastralReference } from './cadastral';
export { validateOwnershipPercentages, type OwnershipEntry, type OwnershipValidationResult } from './ownership';
```
  </action>
  <verify>
Run: `npx tsc --noEmit` - no TypeScript errors
Test (manually or with console):
- validateNieNif('X1234567L') returns boolean
- validateIban('ES7621000813610123456789').valid returns true/false
- validateCadastralReference('1234567890123456AB12') returns boolean
- validateOwnershipPercentages([{ownerId:'1',percentage:50},{ownerId:'2',percentage:50}]).valid returns true
  </verify>
  <done>
All validator files created with proper exports.
Each validator handles edge cases (empty input, spaces, normalization).
IBAN returns error codes for i18n-compatible messages.
Ownership uses basis points to avoid floating point issues.
  </done>
</task>

</tasks>

<verification>
1. Run `npm ls better-dni ibantools` - both packages installed
2. Run `npx tsc --noEmit` - no TypeScript errors
3. All exports available from src/lib/validators/index.ts
4. NIE/NIF validator uses better-dni library (not custom regex)
5. IBAN validator returns structured result with error codes
6. Cadastral validator implements the 20-character checksum algorithm
7. Ownership validator uses basis points (integers) for precision
</verification>

<success_criteria>
- better-dni and ibantools installed
- src/lib/validators/ directory exists with 5 files
- All validators compile without TypeScript errors
- Validators can be imported from '@/lib/validators'
- Each validator handles empty/null input gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/02-owner-property-data/02-02-SUMMARY.md`
</output>
