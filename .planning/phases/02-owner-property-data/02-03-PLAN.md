---
phase: 02-owner-property-data
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - src/hooks/useOwnerSchemas.ts
  - src/stores/owner-form.ts
  - src/app/[locale]/(protected)/owners/page.tsx
  - src/app/[locale]/(protected)/owners/new/page.tsx
  - src/app/[locale]/(protected)/owners/[id]/page.tsx
  - src/app/[locale]/(protected)/owners/actions.ts
  - src/components/owners/owner-form.tsx
  - src/components/owners/owner-card.tsx
  - src/components/owners/tax-id-input.tsx
  - src/components/ui/stepper.tsx
  - src/components/ui/select.tsx
  - src/messages/es.json
  - src/messages/en.json
  - src/messages/de.json
  - src/messages/fr.json
autonomous: true

must_haves:
  truths:
    - "User can register individual owner with validated NIE and fiscal residence"
    - "User can register company owner with validated NIF"
    - "User can enter IBAN for refunds with validation"
    - "Owner data persists to database via server actions"
    - "Multi-step form saves progress between steps"
  artifacts:
    - path: "src/hooks/useOwnerSchemas.ts"
      provides: "Zod schemas for owner forms with i18n validation messages"
      exports: ["useOwnerSchema", "useOwnerStep1Schema", "useOwnerStep2Schema", "useOwnerStep3Schema"]
    - path: "src/stores/owner-form.ts"
      provides: "Zustand store for multi-step owner form persistence"
      exports: ["useOwnerFormStore"]
    - path: "src/app/[locale]/(protected)/owners/actions.ts"
      provides: "Server actions for owner CRUD"
      exports: ["createOwner", "updateOwner", "deleteOwner", "getOwners", "getOwnerById"]
    - path: "src/components/owners/owner-form.tsx"
      provides: "Multi-step wizard form for owner registration"
      min_lines: 100
    - path: "src/components/owners/tax-id-input.tsx"
      provides: "NIE/NIF input with real-time validation feedback"
      min_lines: 40
  key_links:
    - from: "src/components/owners/owner-form.tsx"
      to: "src/stores/owner-form.ts"
      via: "useOwnerFormStore import"
      pattern: "useOwnerFormStore"
    - from: "src/app/[locale]/(protected)/owners/actions.ts"
      to: "src/db"
      via: "database insert/update"
      pattern: "db\\.insert.*owners|db\\.update.*owners"
    - from: "src/components/owners/tax-id-input.tsx"
      to: "src/lib/validators"
      via: "validator import"
      pattern: "validateNieNif|getNieNifType"
---

<objective>
Implement owner management with multi-step registration wizard, server actions for CRUD operations, and real-time validation for NIE/NIF and IBAN.

Purpose: Fulfill OWNER-01 through OWNER-07 requirements - users need to register fiscal identity data for tax declarations
Output: Complete owner management feature with list, create, edit pages and accessible multi-step form
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-owner-property-data/02-RESEARCH.md
@.planning/phases/01-foundation/01-04-SUMMARY.md

# Phase 1 established patterns:
# - Zod schemas as hooks for i18n (useAuthSchemas.ts)
# - Server actions return {error: string} or {success: string}
# - react-hook-form + zodResolver pattern
# - Protected routes under (protected) group

# Existing components to use:
@src/components/ui/button.tsx
@src/components/ui/input.tsx
@src/components/ui/label.tsx
@src/components/ui/form.tsx
@src/components/ui/card.tsx

# Schema and validators from earlier plans:
@src/db/schema.ts
@src/lib/validators/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add UI components (Select, Stepper) and translations</name>
  <files>
    src/components/ui/select.tsx
    src/components/ui/stepper.tsx
    src/messages/es.json
    src/messages/en.json
    src/messages/de.json
    src/messages/fr.json
  </files>
  <action>
**1. Add shadcn/ui Select component:**

Run: `npx shadcn@latest add select`

If shadcn CLI not available, create manually following shadcn/ui new-york style with:
- Radix Select primitive
- 48px touch targets (h-12)
- 18px text size

**2. Create Stepper component** at src/components/ui/stepper.tsx:
```typescript
'use client';

import { cn } from '@/lib/utils';
import { Check } from 'lucide-react';

interface StepperProps {
  steps: string[];
  currentStep: number;
  className?: string;
}

export function Stepper({ steps, currentStep, className }: StepperProps) {
  return (
    <nav aria-label="Progress" className={cn('mb-8', className)}>
      <ol className="flex items-center justify-between">
        {steps.map((step, index) => {
          const stepNumber = index + 1;
          const isCompleted = stepNumber < currentStep;
          const isCurrent = stepNumber === currentStep;

          return (
            <li key={step} className="flex flex-1 items-center">
              <div className="flex flex-col items-center">
                <div
                  className={cn(
                    'flex h-12 w-12 items-center justify-center rounded-full border-2 text-lg font-semibold',
                    isCompleted && 'border-primary bg-primary text-primary-foreground',
                    isCurrent && 'border-primary text-primary',
                    !isCompleted && !isCurrent && 'border-muted-foreground text-muted-foreground'
                  )}
                  aria-current={isCurrent ? 'step' : undefined}
                >
                  {isCompleted ? (
                    <Check className="h-6 w-6" aria-hidden="true" />
                  ) : (
                    stepNumber
                  )}
                </div>
                <span
                  className={cn(
                    'mt-2 text-sm font-medium',
                    (isCompleted || isCurrent) ? 'text-foreground' : 'text-muted-foreground'
                  )}
                >
                  {step}
                </span>
              </div>
              {index < steps.length - 1 && (
                <div
                  className={cn(
                    'mx-2 h-0.5 flex-1',
                    isCompleted ? 'bg-primary' : 'bg-muted'
                  )}
                  aria-hidden="true"
                />
              )}
            </li>
          );
        })}
      </ol>
    </nav>
  );
}
```

**3. Add owner translations** to all 4 language files.

Add to each messages file under "owner" namespace:
```json
{
  "owner": {
    "title": "Propietarios",
    "addNew": "Nuevo propietario",
    "noOwners": "No hay propietarios registrados",
    "addFirst": "Registra tu primer propietario para comenzar",

    "steps": {
      "type": "Tipo",
      "identity": "Identidad",
      "residence": "Residencia",
      "bank": "Banco"
    },

    "form": {
      "ownerType": "Tipo de propietario",
      "individual": "Persona fisica",
      "company": "Empresa",

      "taxId": "NIE/NIF",
      "taxIdHint": "Introduce tu NIE o NIF con letra",
      "taxIdValid": "Identificador valido",
      "taxIdInvalid": "Identificador no valido",

      "firstName": "Nombre",
      "lastName": "Apellidos",
      "companyName": "Razon social",

      "residenceCountry": "Pais de residencia fiscal",
      "residenceAddress": "Direccion",
      "residenceCity": "Ciudad",
      "residencePostalCode": "Codigo postal",

      "iban": "IBAN (para devoluciones)",
      "ibanHint": "Tu cuenta bancaria para recibir devoluciones",
      "ibanOptional": "Opcional - solo necesario si esperas devolucion"
    },

    "actions": {
      "next": "Siguiente",
      "back": "Atras",
      "save": "Guardar propietario",
      "edit": "Editar",
      "delete": "Eliminar",
      "confirmDelete": "Â¿Eliminar este propietario?"
    },

    "success": {
      "created": "Propietario creado correctamente",
      "updated": "Propietario actualizado correctamente",
      "deleted": "Propietario eliminado"
    }
  }
}
```

Translate appropriately for en.json, de.json, fr.json (English, German, French).
  </action>
  <verify>
- src/components/ui/select.tsx exists and exports Select components
- src/components/ui/stepper.tsx exists with accessible progress indicator
- All 4 message files have "owner" namespace with complete translations
- Run: `npx tsc --noEmit` - no errors
  </verify>
  <done>
Select and Stepper UI components created with 48px touch targets.
Owner translations added to all 4 languages.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Zod schemas and Zustand store for owner form</name>
  <files>
    src/hooks/useOwnerSchemas.ts
    src/stores/owner-form.ts
  </files>
  <action>
**1. Create src/stores/ directory and owner-form.ts:**
```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

export type OwnerType = 'individual' | 'company' | null;

interface OwnerFormData {
  // Step 1: Type
  ownerType: OwnerType;

  // Step 2: Identity
  taxId: string;
  taxIdType: 'NIE' | 'NIF' | null;
  firstName: string;
  lastName: string;
  companyName: string;

  // Step 3: Residence
  residenceCountry: string;
  residenceAddress: string;
  residenceCity: string;
  residencePostalCode: string;

  // Step 4: Bank
  iban: string;
}

interface OwnerFormState {
  step: number;
  data: OwnerFormData;
  editingId: string | null;
  setStep: (step: number) => void;
  updateData: (data: Partial<OwnerFormData>) => void;
  setEditingId: (id: string | null) => void;
  reset: () => void;
}

const initialData: OwnerFormData = {
  ownerType: null,
  taxId: '',
  taxIdType: null,
  firstName: '',
  lastName: '',
  companyName: '',
  residenceCountry: '',
  residenceAddress: '',
  residenceCity: '',
  residencePostalCode: '',
  iban: '',
};

export const useOwnerFormStore = create<OwnerFormState>()(
  persist(
    (set) => ({
      step: 1,
      data: initialData,
      editingId: null,
      setStep: (step) => set({ step }),
      updateData: (newData) =>
        set((state) => ({
          data: { ...state.data, ...newData },
        })),
      setEditingId: (id) => set({ editingId: id }),
      reset: () => set({ step: 1, data: initialData, editingId: null }),
    }),
    {
      name: 'owner-form-storage',
    }
  )
);
```

**2. Create src/hooks/useOwnerSchemas.ts:**
```typescript
import { z } from 'zod';
import { useTranslations } from 'next-intl';
import { validateNieNif } from '@/lib/validators';
import { validateIban } from '@/lib/validators';

export const useOwnerStep1Schema = () => {
  const t = useTranslations('validation');

  return z.object({
    ownerType: z.enum(['individual', 'company'], {
      required_error: t('ownerTypeRequired'),
    }),
  });
};

export const useOwnerStep2Schema = () => {
  const t = useTranslations('validation');

  return z.object({
    taxId: z
      .string()
      .min(1, { message: t('taxIdRequired') })
      .refine(validateNieNif, { message: t('taxIdInvalid') }),
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    companyName: z.string().optional(),
  }).superRefine((data, ctx) => {
    // Type-specific validation handled by parent form
  });
};

export const useOwnerStep3Schema = () => {
  const t = useTranslations('validation');

  return z.object({
    residenceCountry: z
      .string()
      .min(2, { message: t('countryRequired') })
      .max(2, { message: t('countryInvalid') }),
    residenceAddress: z
      .string()
      .min(1, { message: t('addressRequired') }),
    residenceCity: z
      .string()
      .min(1, { message: t('cityRequired') }),
    residencePostalCode: z
      .string()
      .min(1, { message: t('postalCodeRequired') }),
  });
};

export const useOwnerStep4Schema = () => {
  const t = useTranslations('validation');

  return z.object({
    iban: z
      .string()
      .optional()
      .refine(
        (val) => !val || validateIban(val).valid,
        (val) => ({
          message: val ? t(validateIban(val).errorCode || 'ibanInvalid') : '',
        })
      ),
  });
};

// Full schema for server-side validation
export const useOwnerSchema = () => {
  const t = useTranslations('validation');

  return z.object({
    ownerType: z.enum(['individual', 'company']),
    taxId: z.string().min(1).refine(validateNieNif),
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    companyName: z.string().optional(),
    residenceCountry: z.string().length(2),
    residenceAddress: z.string().min(1),
    residenceCity: z.string().min(1),
    residencePostalCode: z.string().min(1),
    iban: z.string().optional(),
  }).superRefine((data, ctx) => {
    if (data.ownerType === 'individual') {
      if (!data.firstName) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: t('firstNameRequired'),
          path: ['firstName'],
        });
      }
      if (!data.lastName) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: t('lastNameRequired'),
          path: ['lastName'],
        });
      }
    } else if (data.ownerType === 'company') {
      if (!data.companyName) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: t('companyNameRequired'),
          path: ['companyName'],
        });
      }
    }
  });
};
```

Add validation translations to each messages file under "validation" namespace (extend existing):
```json
{
  "validation": {
    "ownerTypeRequired": "Selecciona el tipo de propietario",
    "taxIdRequired": "El NIE/NIF es obligatorio",
    "taxIdInvalid": "El NIE/NIF no es valido",
    "firstNameRequired": "El nombre es obligatorio",
    "lastNameRequired": "Los apellidos son obligatorios",
    "companyNameRequired": "La razon social es obligatoria",
    "countryRequired": "El pais es obligatorio",
    "countryInvalid": "Codigo de pais invalido",
    "addressRequired": "La direccion es obligatoria",
    "cityRequired": "La ciudad es obligatoria",
    "postalCodeRequired": "El codigo postal es obligatorio",
    "ibanRequired": "El IBAN es obligatorio",
    "ibanInvalid": "El IBAN no es valido",
    "ibanCountryInvalid": "Pais del IBAN no reconocido",
    "ibanLengthInvalid": "Longitud del IBAN incorrecta",
    "ibanChecksumInvalid": "Digito de control incorrecto"
  }
}
```
  </action>
  <verify>
- src/stores/owner-form.ts exports useOwnerFormStore
- src/hooks/useOwnerSchemas.ts exports all schema hooks
- Run: `npx tsc --noEmit` - no TypeScript errors
- Store persists to localStorage (verified by key name in code)
  </verify>
  <done>
Zustand store created with persistence middleware.
Zod schemas created as hooks with i18n validation messages.
Per-step schemas enable step-by-step validation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create owner pages and server actions</name>
  <files>
    src/app/[locale]/(protected)/owners/page.tsx
    src/app/[locale]/(protected)/owners/new/page.tsx
    src/app/[locale]/(protected)/owners/[id]/page.tsx
    src/app/[locale]/(protected)/owners/actions.ts
    src/app/[locale]/(protected)/layout.tsx
    src/components/owners/owner-form.tsx
    src/components/owners/owner-card.tsx
    src/components/owners/tax-id-input.tsx
  </files>
  <action>
**1. Create protected layout** at src/app/[locale]/(protected)/layout.tsx:
```typescript
import { redirect } from 'next/navigation';
import { createClient } from '@/lib/supabase/server';

export default async function ProtectedLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    redirect('/login');
  }

  return <>{children}</>;
}
```

**2. Create server actions** at src/app/[locale]/(protected)/owners/actions.ts:
```typescript
'use server';

import { revalidatePath } from 'next/cache';
import { createClient } from '@/lib/supabase/server';
import { db } from '@/db';
import { owners } from '@/db/schema';
import { eq, and } from 'drizzle-orm';
import { validateNieNif, normalizeNieNif, getNieNifType } from '@/lib/validators';
import { formatIbanForStorage, validateIban } from '@/lib/validators';

interface OwnerInput {
  ownerType: 'individual' | 'company';
  taxId: string;
  firstName?: string;
  lastName?: string;
  companyName?: string;
  residenceCountry: string;
  residenceAddress: string;
  residenceCity: string;
  residencePostalCode: string;
  iban?: string;
}

export async function createOwner(data: OwnerInput) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return { error: 'Unauthorized' };
  }

  // Validate tax ID
  if (!validateNieNif(data.taxId)) {
    return { error: 'Invalid tax ID' };
  }

  // Validate IBAN if provided
  if (data.iban && !validateIban(data.iban).valid) {
    return { error: 'Invalid IBAN' };
  }

  try {
    const [owner] = await db.insert(owners).values({
      userId: user.id,
      ownerType: data.ownerType,
      taxId: normalizeNieNif(data.taxId),
      taxIdType: getNieNifType(data.taxId),
      firstName: data.firstName || null,
      lastName: data.lastName || null,
      companyName: data.companyName || null,
      residenceCountry: data.residenceCountry,
      residenceAddress: data.residenceAddress,
      residenceCity: data.residenceCity,
      residencePostalCode: data.residencePostalCode,
      iban: data.iban ? formatIbanForStorage(data.iban) : null,
    }).returning();

    revalidatePath('/owners');
    return { success: true, owner };
  } catch (error) {
    console.error('Error creating owner:', error);
    return { error: 'Failed to create owner' };
  }
}

export async function updateOwner(id: string, data: OwnerInput) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return { error: 'Unauthorized' };
  }

  // Validate tax ID
  if (!validateNieNif(data.taxId)) {
    return { error: 'Invalid tax ID' };
  }

  try {
    const [owner] = await db.update(owners)
      .set({
        ownerType: data.ownerType,
        taxId: normalizeNieNif(data.taxId),
        taxIdType: getNieNifType(data.taxId),
        firstName: data.firstName || null,
        lastName: data.lastName || null,
        companyName: data.companyName || null,
        residenceCountry: data.residenceCountry,
        residenceAddress: data.residenceAddress,
        residenceCity: data.residenceCity,
        residencePostalCode: data.residencePostalCode,
        iban: data.iban ? formatIbanForStorage(data.iban) : null,
        updatedAt: new Date(),
      })
      .where(and(eq(owners.id, id), eq(owners.userId, user.id)))
      .returning();

    revalidatePath('/owners');
    return { success: true, owner };
  } catch (error) {
    console.error('Error updating owner:', error);
    return { error: 'Failed to update owner' };
  }
}

export async function deleteOwner(id: string) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return { error: 'Unauthorized' };
  }

  try {
    await db.delete(owners)
      .where(and(eq(owners.id, id), eq(owners.userId, user.id)));

    revalidatePath('/owners');
    return { success: true };
  } catch (error) {
    console.error('Error deleting owner:', error);
    return { error: 'Failed to delete owner' };
  }
}

export async function getOwners() {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return [];
  }

  return db.select().from(owners).where(eq(owners.userId, user.id));
}

export async function getOwnerById(id: string) {
  const supabase = await createClient();
  const { data: { user } } = await supabase.auth.getUser();

  if (!user) {
    return null;
  }

  const [owner] = await db.select()
    .from(owners)
    .where(and(eq(owners.id, id), eq(owners.userId, user.id)));

  return owner || null;
}
```

**3. Create TaxIdInput component** at src/components/owners/tax-id-input.tsx:
Follow the pattern from 02-RESEARCH.md with real-time validation feedback, green/red border, and accessible labels.

**4. Create OwnerForm component** at src/components/owners/owner-form.tsx:
Multi-step wizard using:
- Stepper component for progress
- useOwnerFormStore for state
- Per-step Zod schemas
- react-hook-form for each step
- Step 1: Owner type selection (individual/company)
- Step 2: Tax ID + name fields (conditional on type)
- Step 3: Fiscal residence (country, address, city, postal)
- Step 4: IBAN (optional)
- Navigation: Back/Next buttons, Save on final step

**5. Create OwnerCard component** at src/components/owners/owner-card.tsx:
Display owner info with edit/delete actions.

**6. Create pages:**
- owners/page.tsx: List all owners with add button
- owners/new/page.tsx: New owner wizard
- owners/[id]/page.tsx: Edit existing owner

All pages follow patterns from Phase 1:
- setRequestLocale() for static rendering
- Accessible typography (18px+)
- Card-based layout
  </action>
  <verify>
Run: `npx tsc --noEmit` - no TypeScript errors
Run: `npm run build` - build succeeds
Verify: Protected layout redirects to login if not authenticated
Verify: Server actions use auth check and row-level filtering by userId
  </verify>
  <done>
Owner management feature complete with:
- Protected route layout
- CRUD server actions with validation
- Multi-step wizard form with persistence
- Real-time NIE/NIF validation feedback
- List, create, edit pages
- All UI accessible (18px text, 48px buttons)
  </done>
</task>

</tasks>

<verification>
1. Run `npm run build` - no build errors
2. Navigate to /owners - redirects to login if not authenticated
3. Create owner flow: 4 steps with progress indicator
4. NIE/NIF input shows green/red validation feedback
5. Server actions verify user auth and filter by userId
6. Owner persists to database after final step
7. Edit/delete actions work correctly
8. Translations display in all 4 languages
</verification>

<success_criteria>
- Protected layout enforces authentication
- Owner CRUD operations work via server actions
- Multi-step form persists state across steps
- NIE/NIF validation uses checksum (better-dni)
- IBAN validation shows specific error messages
- All text is 18px+, buttons are 48px touch targets
- Works in es/en/de/fr languages
</success_criteria>

<output>
After completion, create `.planning/phases/02-owner-property-data/02-03-SUMMARY.md`
</output>
